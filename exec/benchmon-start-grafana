#!/usr/bin/env python3
# filepath: /home/wangfeng/work/ska-sdp-benchmark-monitor/benchmon/exec/benchmon-run-grafana
import argparse
import json
import os
import socket
import subprocess
import sys
import time
from pathlib import Path
import requests
from requests.auth import HTTPBasicAuth
import logging


# Get application paths from environment variables, with sensible defaults
INFLUXDB_PATH = os.environ.get("BENCHMON_INFLUXDB_PATH", "./benchmon-stack/influxdb")
GRAFANA_PATH = os.environ.get("BENCHMON_GRAFANA_PATH", "./benchmon-stack/grafana")

INFLUXDB_BINARY = f"{INFLUXDB_PATH}/influxdb3"
GRAFANA_BINARY = f"{GRAFANA_PATH}/bin/grafana-server"

def is_port_in_use(port: int) -> bool:
    """Checks if a TCP port is in use on localhost."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0
    
def setup_influxdb_datasource(grafana_port: int, influxdb_port: int) -> bool:
    """
    Configures Grafana to use InfluxDB as a data source.
    """

    grafana_url = f"http://localhost:{grafana_port}"

    # --- MODIFICATION: Temporarily suppress connection errors during wait ---
    print("Waiting for Grafana to be ready...")
    original_log_level = logging.getLogger().getEffectiveLevel()
    logging.getLogger().setLevel(logging.CRITICAL)  # Suppress errors

    session = requests.Session()
    session.auth = HTTPBasicAuth("admin", "admin")

    start_time = time.time()
    grafana_ready = False
    while time.time() - start_time < 60:
        try:
            response = session.get(
                f"{grafana_url}/api/health",
                timeout=60
            )
            if response.status_code == 200:
                grafana_ready = True
                break
        except requests.RequestException:
            pass
        print("Grafana not ready yet, retrying in 2 seconds...")
        time.sleep(2)

    logging.getLogger().setLevel(original_log_level)  # Restore log level

    if not grafana_ready:
        print("Error: Grafana did not become available in time. Please check logs.", file=sys.stderr)
        # Consider stopping the services here if Grafana fails to start
        sys.exit(1)

    print("Grafana is up. Configuring datasource and dashboards...")

    # Configure datasource

    payload = {
        "name": "InfluxDB v3 SQL",
        "type": "influxdb",
        "uid": "influxdb-v3-sql",
        "access": "proxy",
        "url": f"http://localhost:{influxdb_port}",
        "basicAuth": False,
        "isDefault": True,
        "jsonData": {
            "dbName": "metrics",
            "queryLanguage": "sql",
            "version": "SQL",
            "httpMode": "GET",
            "tlsSkipVerify": True,
            "insecureConnection": True,
            "insecureGrpc": True
        },
        "secureJsonData": {}
    }

    datasource_ready = False

    response = session.get(f"{grafana_url}/api/datasources/uid/{payload['uid']}")
    if response.status_code == 200:
        print("Datasource already exists, skipping creation.")
        datasource_ready = True
    else:
        response = session.post(
            f"{grafana_url}/api/datasources",
            json=payload,
            headers={"Content-Type": "application/json"}
        )
        if response.status_code in (200, 201):
            print("Datasource created successfully.")
            datasource_ready = True
        else:
            print(f"Error creating datasource: {response.status_code} {response.text}", file=sys.stderr)

    return datasource_ready


def setup_grafana_dashboards(grafana_port: int, dashboard_dir: Path) -> bool:
    """
    Uploads dashboards from the specified directory to Grafana.
    """
    grafana_url = f"http://localhost:{grafana_port}"
    session = requests.Session()
    session.auth = HTTPBasicAuth("admin", "admin")

    if not dashboard_dir.is_dir():
        print(f"Error: Dashboard directory {dashboard_dir} does not exist or is not a directory.", file=sys.stderr)
        return False

    success = True
    for dashboard_file in dashboard_dir.glob("*.json"):
        print(f"Uploading dashboard: {dashboard_file.name}")
        with open(dashboard_file, "r") as f:
            dashboard_json = json.load(f)

        payload = {
            "dashboard": dashboard_json,
            "overwrite": True,
            "message": f"Uploaded {dashboard_file} via benchmon-run-grafana"
        }

        if "id" in payload["dashboard"]:
            del payload["dashboard"]["id"]

        response = session.post(
            f"{grafana_url}/api/dashboards/db",
            json=payload,
            headers={"Content-Type": "application/json"}
        )

        if response.status_code in (200, 201):
            print(f"Dashboard {dashboard_file.name} uploaded successfully.")
        else:
            print(f"Error uploading dashboard {dashboard_file.name}: {response.status_code} {response.text}", file=sys.stderr)
            success = False

    return success

def main():
    parser = argparse.ArgumentParser(description="Start Benchmon Grafana/InfluxDB Stack")
    parser.add_argument(
        "--save-dir",
        type=Path,
        help="Base directory for traces. Defaults to current directory."
    )
    parser.add_argument("--influxdb-port", type=int, default=8181, help="Port for InfluxDB")
    parser.add_argument("--grafana-port", type=int, default=3000, help="Port for Grafana")
    # --- MODIFICATION: Remove hardcoded default ---
    parser.add_argument(
        "--dashboard-dir",
        type=Path,
        default=None,
        help="Directory containing dashboard JSON files. Defaults to internal package dashboards."
    )
    args = parser.parse_args()

    # --- MODIFICATION: Programmatically find default dashboard directory ---
    if args.dashboard_dir is None:
        fallback_path = Path(__file__).parent.parent / "grafana" / "dashboards"
        if fallback_path.is_dir():
            args.dashboard_dir = fallback_path
            print(f"--dashboard-dir not provided, using fallback development path: {args.dashboard_dir}")
  


    # --- MODIFICATION: Align directory logic with benchmon-run ---
    # The traces_dir is now the primary directory, not a subdirectory.
    traces_dir = args.save_dir if args.save_dir is not None else Path("./benchmon_traces_")
    print(f"Using traces directory: {traces_dir.resolve()}")


    # 1. Prepare runtime directory inside the traces directory
    runtime_dir = traces_dir / "grafana-data"
    runtime_dir.mkdir(parents=True, exist_ok=True)

    influxdb_data_dir = runtime_dir / "influxdb_data"
    influxdb_data_dir.mkdir(exist_ok=True)

    log_dir = runtime_dir / "logs"
    log_dir.mkdir(exist_ok=True)

    pid_file = runtime_dir / "pids.json"
    connection_file = runtime_dir / "connection.json"

    # 2. Check for required binaries
    if not Path(INFLUXDB_BINARY).is_file():
        print(f"Error: InfluxDB binary not found at {INFLUXDB_BINARY}", file=sys.stderr)
        print(f"Hint: Set the BENCHMON_INFLUXDB_PATH environment variable.", file=sys.stderr)
        sys.exit(1)
    if not Path(GRAFANA_BINARY).is_file():
        print(f"Error: Grafana binary not found at {GRAFANA_BINARY}", file=sys.stderr)
        print(f"Hint: Set the BENCHMON_GRAFANA_PATH environment variable.", file=sys.stderr)
        sys.exit(1)

    # 3. Check ports
    if is_port_in_use(args.influxdb_port):
        print(f"Error: Port {args.influxdb_port} for InfluxDB is already in use.", file=sys.stderr)
        sys.exit(1)
    if is_port_in_use(args.grafana_port):
        print(f"Error: Port {args.grafana_port} for Grafana is already in use.", file=sys.stderr)
        sys.exit(1)

    pids = {}
    
    # 4. Start InfluxDB
    print(f"Starting InfluxDB on port {args.influxdb_port}...")
    influx_log_file = log_dir / "influxdb.log"
    
    # --- MODIFICATION: Use short hostname for node-id, like in the shell script ---
    node_id = "benchmon-node-id"
    print(f"Using node-id: {node_id}")

    with open(influx_log_file, "w") as log:
        influx_process = subprocess.Popen(
            [
                INFLUXDB_BINARY, "serve",
                "--object-store", "file",
                "--node-id", node_id,
                "--http-bind", f"0.0.0.0:{args.influxdb_port}",
                "--data-dir", str(influxdb_data_dir),
                "--without-auth"
            ],
            stdout=log, stderr=subprocess.STDOUT
        )
    pids["influxdb"] = influx_process.pid
    print(f"InfluxDB started with PID: {influx_process.pid}. Log: {influx_log_file}")

    # 5. Start Grafana
    print(f"Starting Grafana on port {args.grafana_port}...")
    grafana_log_file = log_dir / "grafana.log"
    with open(grafana_log_file, "w") as log:
        grafana_process = subprocess.Popen(
            [GRAFANA_BINARY, f"--config={GRAFANA_PATH}/conf/defaults.ini",
             f"--homepath={GRAFANA_PATH}", f"cfg:server.http_port={args.grafana_port}"],
            stdout=log, stderr=subprocess.STDOUT
        )
    pids["grafana"] = grafana_process.pid
    print(f"Grafana started with PID: {grafana_process.pid}. Log: {grafana_log_file}")

    # 6. Write PID and connection info files
    with open(pid_file, "w") as f:
        json.dump(pids, f)
    print(f"PIDs saved to {pid_file}")

    # --- MODIFICATION: Use hostname instead of IP address ---
    hostname = socket.gethostname()
    connection_info = {
        "influxdb_url": f"http://{hostname}:{args.influxdb_port}",
        "grafana_url": f"http://{hostname}:{args.grafana_port}",
        "influxdb_token": ""  # Placeholder for token
    }
    with open(connection_file, "w") as f:
        json.dump(connection_info, f)
    print(f"Connection info saved to {connection_file}")

    print("\n--- Post-start Configuration ---")

    # Setup InfluxDB data source in Grafana
    if not setup_influxdb_datasource(args.grafana_port, args.influxdb_port):
        print("Error: Failed to set up InfluxDB data source in Grafana.", file=sys.stderr)
        sys.exit(1)

    # Upload dashboards
    if not setup_grafana_dashboards(args.grafana_port, args.dashboard_dir):
        print("Error: Failed to upload one or more dashboards to Grafana.", file=sys.stderr)
        sys.exit(1)

    print("\nMonitoring stack started and configured successfully.")

if __name__ == "__main__":
    main()